(**
  Main
*)

open ExtLib

module L = List
module S = String

let parse_one_exn (sql,props) =
    if Sqlgg_config.debug1 () then Printf.eprintf "------\n%s\n%!" sql;
    let (sql,schema,params,kind) = Syntax.parse sql in
    begin match kind, !Gen.params_mode with
    | Insert (Some _,_,_), None -> Error.log "Cannot use `-params none` with autogenerated parameters"
    | _ -> ()
    end;
    let props = Props.set props "sql" sql in
    { Gen.schema; params; kind; props }

let parse_one (sql, props as x) =
  try
    Some (parse_one_exn x)
  with
  | Parser_utils.Error (exn,(line,cnum,tok,tail)) ->
    begin
     let extra = match exn with
     | Sql.Schema.Error (_,msg) -> msg
     | exn -> Printexc.to_string exn
     in
     Error.log "==> %s" sql;
     if cnum = String.length sql && tok = "" then
       Error.log "Error: %s" extra
     else
       Error.log "Position %u:%u Tokens: %s%s\nError: %s" line cnum tok (String.slice ~last:32 tail) extra;
     None
    end
  | exn ->
(*     let bt = Printexc.get_raw_backtrace () in *)
    Error.log "Failed %s: %s" (Option.default "" @@ Props.get props "name") sql;
    raise exn
(*     Printexc.raise_with_backtrace exn bt *)

let parse_one (sql,props as x) =
  match Props.get props "noparse" with
  | Some _ -> Some { Gen.schema=[]; params=[]; kind=Stmt.Other; props=Props.set props "sql" sql }
  | None -> parse_one x

let drop_while p e =
  while Option.map p (Enum.peek e) = Some true do
    Enum.junk e
  done

type token = [`Comment of string | `Token of string | `Char of char |
              `Space of string | `Prop of string * string | `Semicolon ]

let get_statements ch =
  let lexbuf = Lexing.from_channel ch in
  let tokens = Enum.from (fun () ->
    if lexbuf.Lexing.lex_eof_reached then raise Enum.No_more_elements else
    match Sql_lexer.ruleStatement lexbuf with
    | `Eof -> raise Enum.No_more_elements
    | #token as x -> x)
  in
  let extract () =
    let b = Buffer.create 1024 in
    let props = ref Props.empty in
    let answer () = Buffer.contents b, !props in
    let rec loop smth =
      match Enum.get tokens with
      | None -> if smth then Some (answer ()) else None
      | Some x ->
        match x with
        | `Comment s -> ignore s; loop smth (* do not include comments (option?) *)
        | `Char c -> Buffer.add_char b c; loop true
        | `Space _ when smth = false -> loop smth (* drop leading whitespaces *)
        | `Token s | `Space s -> Buffer.add_string b s; loop true
        | `Prop (n,v) -> props := Props.set !props n v; loop smth
        | `Semicolon -> Some (answer ())
    in
    loop false
  in
  let extract () = try extract () with e -> Error.log "lexer failed (%s)" (Printexc.to_string e); None in
  let rec next () =
    match extract () with
    | None -> raise Enum.No_more_elements
    | Some sql ->
      begin match parse_one sql with
      | None -> next ()
      | Some stmt ->
          if not (Sql.Schema.is_unique stmt.schema) then
            Printf.eprintf "Warning: this SQL statement will produce rowset with duplicate column names:\n%s\n" (fst sql);
          stmt
      end
  in
  Enum.from next |> List.of_enum

let with_channel filename f =
  match try Some (open_in filename) with _ -> None with
  | None -> Error.log "cannot open file : %s" filename; f None
  | Some ch -> Std.finally (fun () -> close_in_noerr ch) f (Some ch)
